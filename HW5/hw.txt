1a.
______________________________50______________________________
_______________/______________________________\_______________
______________20______________________________60______________
_______/______________\_______________________________\_______
______10______________40______________________________70______
__________\________/_______________________________/______\___
__________15______30______________________________65______80__
_________________/__\____________________________________/____
________________25__35__________________________________75____
1b.
in-order:   10 15 20 25 30 35 40 50 60 65 70 75 80
pre-order:  50 20 10 15 40 30 25 35 60 70 65 80 75
post-order: 15 10 25 35 30 40 20 65 75 80 70 60 50
1c.
______________________________50______________________________
_______________/______________________________\_______________
______________25______________________________60______________
_______/______________\_______________________________\_______
______10______________40______________________________70______
__________\________/_______________________________/______\___
__________15______35______________________________65______80__
_________________________________________________________/____
________________________________________________________75____
2a.
struct node{
	node* parent;
	node* left;
	node* right;
	int data;
}
2b.
if insert_value is less than current_value
	if current left child is empty
		create new pointer with data
		set current's left child to new pointer
		set new pointer's parent to current
	else
		call function again
else if insert_value is more than current_value
	if current right child is empty
		create new pointer with data
		set current's right child to new pointer
		set new pointer's parent to current
	else
		call function again
else
	this is a duplicate, decide what to do
3a.
___8___
_/___\_
_3___6_
/_\_/__
0_2_4__
3b.
8 3 6 0 2 4
3c.
6 3 4 0 2
4a.
O(C+logS)
4b.
O(logC+S)
4c.
O(logC+logS)
4d.
O(logS)
4e.
O(1)
4f.
O(s+logc)
4g.
O(slogs)
4h.
O(clogs)













